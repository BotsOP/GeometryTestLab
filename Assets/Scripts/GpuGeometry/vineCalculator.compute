// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

RWByteAddressBuffer bufVertices;
RWByteAddressBuffer bufIndices;

RWStructuredBuffer<float3> pathPoints;

// void Store(RWByteAddressBuffer buf, int index, float v)
// {
//     uint3 data = asuint(v);
//     buf.Store3((index*3)<<2, data);
// }

[numthreads(64,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    bufVertices.Store3(sizeof(float3) * id.x, asuint(float3(0, 1, 0) + pathPoints[id.x]));
    bufVertices.Store3(id.x * 3 + 1, asuint(float3(1, 0, 0) + pathPoints[id.x]));
    bufVertices.Store3(id.x * 3 + 2, asuint(float3(0, -1, 0) + pathPoints[id.x]));
    bufVertices.Store3(id.x * 3 + 3, asuint(float3(-1, 0, 0) + pathPoints[id.x]));
    // Store(bufVertices, id.x, float3(0, 1, 0) + pathPoints[id.x]);
    // Store(bufVertices, id.x + 1, float3(1, 0, 0) + pathPoints[id.x]);
    // Store(bufVertices, id.x + 2, float3(0, -1, 0) + pathPoints[id.x]);
    // Store(bufVertices, id.x + 3, float3(-1, 0, 0) + pathPoints[id.x]);

    // for (int i = 0; i < 4; i++)
    // {
    //     for (int j = 0; j < 3; j++)
    //     {
    //         int index = id.x + i + j;
    //         int A = id.x + i;
    //         int B = id.x + i + 1;
    //         int Anext = id.x + i + 4;
    //         int Bnext = id.x + i + 4 + 1;
    //
    //         if(i % 2 == 0)
    //         {
    //             Store(bufVertices, index, A);
    //             Store(bufVertices, index, Anext);
    //             Store(bufVertices, index, B);
    //         }
    //         else
    //         {
    //             Store(bufVertices, index, B);
    //             Store(bufVertices, index, Anext);
    //             Store(bufVertices, index, Bnext);
    //         }
    //         
    //     }
    // }
    
}
