// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CalculateVertex
#pragma kernel CalculateIndex

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

RWByteAddressBuffer bufVertices;
RWByteAddressBuffer bufIndice;

StructuredBuffer<float4x4> pathPoints;

int roundSegments;
int bezierSubSegments;
int bezierSegments;

float3 getMatrixPos(float4x4 mat)
{
    return float3(mat[0].w, mat[1].w, mat[2].w);
}

float3 GetBezierMatrix(float t, int currentBezierSegment)
{
    int rootBezierIndex = 3 * currentBezierSegment;
    float3 p0 = getMatrixPos(pathPoints[rootBezierIndex + 0]);
    float3 p1 = getMatrixPos(pathPoints[rootBezierIndex + 1]);
    float3 p2 = getMatrixPos(pathPoints[rootBezierIndex + 2]);
    float3 p3 = getMatrixPos(pathPoints[rootBezierIndex + 3]);

    float3 a = lerp(p0, p1, t);
    float3 b = lerp(p1, p2, t);
    float3 c = lerp(p2, p3, t);
    
    float3 d = lerp(a, b, t);
    float3 e = lerp(b, c, t);
    
    float3 newMatrix = lerp(d, e, t);

    return newMatrix;
}

[numthreads(64,1,1)]
void CalculateVertex (uint3 id : SV_DispatchThreadID)
{
    int currentVertex = id.x % roundSegments;
    int currentSegment = id.x / roundSegments;
    int currentBezierSegment = id.x / (roundSegments * bezierSubSegments);
    
    float t = (float)(currentSegment) / (float)(bezierSubSegments - 1);
    t = t - 1 * currentBezierSegment;

    float angle = 3.14159265f * 2.0f * (float)currentVertex / (float)roundSegments;
    float x = cos(angle);
    float y = sin(angle);
    
    float3 normal = float3(x, y, 0);
    //float3 vertPos = mul(GetBezierMatrix(t), float4(x, y, 0, 1));
    float3 vertPos = normal + GetBezierMatrix(t, currentBezierSegment);
    
    bufVertices.Store3(id.x * 12, asuint(float3(GetBezierMatrix(t, currentBezierSegment).x, t, currentBezierSegment)));
    //bufVertices.Store3(id.x * 24 + 12, asuint(float3(9999,9999,9999)));
}

[numthreads(32,1,1)]
void CalculateIndex (uint3 id : SV_DispatchThreadID)
{
    const int currentSegment = id.x / roundSegments;
    const int nextSegment = currentSegment + 1;
    const int rootIndex = id.x;
    const int A = rootIndex;
    const int B = roundSegments * currentSegment + (id.x + 1) % roundSegments;
    const int ANext = rootIndex + roundSegments;
    const int BNext = roundSegments * currentSegment + (id.x + 1) % roundSegments + roundSegments;
    
    int localAddress = id.x * 6;
    
    bufIndice.Store((localAddress + 0) * 4, asuint(A));
    bufIndice.Store((localAddress + 1) * 4, asuint(B));
    bufIndice.Store((localAddress + 2) * 4, asuint(ANext));
    
    bufIndice.Store((localAddress + 3) * 4, asuint(B));
    bufIndice.Store((localAddress + 4) * 4, asuint(BNext));
    bufIndice.Store((localAddress + 5) * 4, asuint(ANext));
}
